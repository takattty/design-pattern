## StateパターンとStrategyパターンの違い

実装クラスの決定を、IFの前と後ろのどちらかで決めるか。\
Strategyパターンだと、 IFの前（IFのメソッドを呼び出す前に、どの実装クラスを使うか決める）\
Stateパターンだと、IFの後ろ（実装クラス自体やその依存関係から、次の実装クラスが決まる）

確かに戦術の話になると、具体的な戦術クラスが次の戦術を決めるとかはイメージできない。\
ただ状態遷移だと、どの状態からどの状態へって感じで具体的に知ってないと具象クラスの切り替えができないイメージ。


ただ、今回の例ではいくつか謎なポイントがあったので、そこは今後深掘りする必要あり。

- なぜ具象クラスがシングルトンなのか
- enumでできないのか
- 状態遷移自体も、enumやmap等で表現できないか
- 具体的にどんなユースケースがあるか（Webアプリとして考える）
- 状態を表すクラスに状態を持たせられるのか


### 構造理解
自分の理解
1. どういう状況か
    1. オブジェクトの状態に合わせた処理を行いたい場合
2. どういう問題か
    1. オブジェクト同士がバラバラだと、利用する側が全てのオブジェクトの監視や管理を行う必要が出てくる
3. どういう解決策か
    1. オブジェクト同士で、監視や管理を行い利用する側をシンプルにする

↓

claude.aiの説明
1. どういう状況か
    - オブジェクトの内部状態に応じて、振る舞いを変更する必要がある場合
    - オブジェクトの状態が変化することで、実行すべき処理や振る舞いが変わる場合
    - 状態の種類が多く、状態ごとの処理が複雑な場合

2. どういう問題か
    - 状態に応じた処理を1つのクラス内で実装すると、条件分岐が複雑になり、コードの可読性と保守性が低下する
    - 新しい状態を追加する際に、既存のコードを修正する必要があり、変更の影響が大きくなる
    - 状態ごとの処理が分散していると、状態間の遷移や依存関係が把握しにくくなる

3. どういう解決策か
    - 状態を表すインターフェースを定義し、各状態をそのインターフェースを実装するクラスとして表現する
    - 状態ごとの処理を、対応する状態クラスに移動させ、状態クラス内でカプセル化する
    - コンテキスト（状態を持つオブジェクト）は、現在の状態を表すインスタンスを保持し、状態に依存する処理を委譲する
    - 状態の遷移は、状態クラス間で行われ、コンテキストは状態の変更を状態クラスに委ねる
    - 新しい状態を追加する際は、新しい状態クラスを作成し、既存のコードに影響を与えずに拡張できる

↓\
↓

再解釈
1. どういう状況か
    1. オブジェクトの状態毎に処理や振る舞いを変えたい場合
2. どういう問題か
    1. 状態監視や管理が利用する側の負担になってしまう
3. どういう解決策か
    1. 状態監視や管理は各オブジェクトが似ない、利用する側はIFの振る舞いから操作するだけ 