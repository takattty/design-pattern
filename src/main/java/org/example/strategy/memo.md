# Strategyパターンの例 - `Comparator<T>`
- module: java.base
- package: java.util

## メモ
```java
public interface Comparator<T> {
    int compare(T o1, T o2); 
}

public class Arrays {
    public static <T> void sort(T[] a, Comparator<? super T> c) {}
}

class HogeComparator implements Comparator<T> {
    @Override
    public int compare(Hoge h1, Hoge h2) {} 
}

// ここで比較方法を変えている（いわゆる戦術部分）
// オブジェクトの状態はどうでもいいので、Strategyパターンとなるイメージ
// Arrays.sort(hoge, HogeComparator);
```

### 構造理解
自分の理解
1. どういう状況か
   1. 同じ操作に対して、複数の手段を切り替えたい場合
2. どういう問題か
   1. 別々の呼び出し方だと、手段が変わる毎に修正しないといけない
3. どういう解決策か 
   1. 共通のIF型を持つ手段を作成し、具体的な手段は各処理に任せる

↓

claude.aiの説明
1. どういう状況か
   - あるタスクを実行するために、複数のアルゴリズムや手段が存在する場合
   - 実行時に、状況に応じてアルゴリズムや手段を切り替えたい場合
   - 同じインターフェースを持つ複数の実装を切り替えて使用したい場合

2. どういう問題か
   - 各アルゴリズムや手段が独自のインターフェースを持っていると、利用する側のコードが複雑になる
   - アルゴリズムや手段を切り替える際に、利用する側のコードを修正する必要がある
   - 新しいアルゴリズムや手段を追加する際に、利用する側のコードに影響が及ぶ

3. どういう解決策か
   - アルゴリズムや手段を表す共通のインターフェースを定義する
   - 各アルゴリズムや手段は、共通のインターフェースを実装する具体的なクラスとして実装する
   - 利用する側のコードは、共通のインターフェースを通じてアルゴリズムや手段を利用する
   - 実行時に、状況に応じて具体的なアルゴリズムや手段を切り替えることができる
   - 新しいアルゴリズムや手段を追加する際は、共通のインターフェースを実装するだけで、利用する側のコードに影響を与えない

↓\
↓

再解釈
1. どういう状況か 
   1. あるタスクを実行時の状況に応じて、複数の実装を切り替えたい場合
2. どういう問題か
   1. 各実装を切り替えたい場合、共通のIFでなければ利用する側のコードが切り替えが必要になり複雑になる
3. どういう解決策か
   1. 共通のIFを各自実装し、利用する側はIFを通じて実装を利用する


利用する側への影響を最小限に、という考えが根本にある。\
その上で手段をどう切り替えるかが、Strategyパターンのポイント。

なので、自分で実装する際には「共通のIFを作成して、それを元に外から切り替えられるように設計する」ところに気を付けたほうが良さそう。
